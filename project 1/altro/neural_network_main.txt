
if __name__ == "__main__":
    learning_rate = 0.1
    neurons_in_each_layer = [2, 3, 3, 2]
    activation_functions = [
        "relu", "relu", "linear"]
    softmax = True
    loss_function = "cross_entropy"
    global_weight_regularization_option = None
    global_weight_regularization_rate = None
    initial_weight_ranges = "glorot"
    initial_bias_ranges = [0, 0]
    verbose = False
    
    layer_list = [{'units': 2, 'activation': 'none'}, {'units': 4, 'activation': 'relu'}, 
                  {'units': 3, 'activation': 'relu'},
                  {'units': 2, 'activation': 'linear'}]

    nn = NeuralNetwork(learning_rate, layer_list, 
                 softmax, loss_function, global_weight_regularization_option, 
                 global_weight_regularization_rate, initial_weight_ranges, 
                 initial_bias_ranges, verbose)

    def XOR_data(count):
        X = np.empty((count, 2))
        targets = np.empty((count, 2))

        index = 0
        # 01 = 0
        # 10 = 1 # lmao
        for i in range(count // 4):
            for j in range(2):
                # X[index, j] = np.random.uniform(0.0, 0.5)
                X[index, j] = 0.0

            targets[index, 0] = 0.0
            targets[index, 1] = 1.0
            index += 1

        # (1, 1) = 0
        for i in range(count // 4):
            for j in range(2):
                # X[index, j] = np.random.uniform(0.5, 1.0)
                X[index, j] = 1.0

            targets[index, 0] = 0.0
            targets[index, 1] = 1.0
            index += 1

        # (0, 1) = 1
        for i in range(count // 4):
            # X[index, 0] = np.random.uniform(0.0, 0.5)
            # X[index, 1] = np.random.uniform(0.5, 1.0)
            X[index, 0] = 0.0
            X[index, 1] = 1.0
            targets[index, 0] = 1.0
            targets[index, 1] = 0.0
            index += 1

        # (1, 0) = 1
        for i in range(count // 4):
            # X[index, 0] = np.random.uniform(0.5, 1.0)
            # X[index, 1] = np.random.uniform(0.0, 0.5)
            X[index, 0] = 1.0
            X[index, 1] = 0.0
            targets[index, 0] = 1.0
            targets[index, 1] = 0.0
            index += 1

        shuffle_indexes = np.arange(count)
        np.random.shuffle(shuffle_indexes)
        X = X[shuffle_indexes]
        targets = targets[shuffle_indexes]

        return X, targets

    epochs = 40
    batch_size = 64
    X, Y = XOR_data(20000)

    X_train, Y_train, X_val, Y_val, X_test, Y_test = split_dataset(X, Y)

    # print("Outputs:\n", X)

    # print("Targets:\n", targets)

    train_loss_history, train_accuracy_history, val_loss_history, val_accuracy_history = nn.train(
        epochs, batch_size, X_train, Y_train, X_val, Y_val)

    #plot_loss_and_accuracy(
        #train_loss_history, train_accuracy_history, val_loss_history, val_accuracy_history)

    input_check = np.array([[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]])
    prediction = nn.predict(input_check)
    prediction = one_hot_encode(prediction.T)
    target_check = np.array([[0.0, 0.0, 1.0, 1.0], [1.0, 1.0, 0.0, 0.0]])
    print("Actual prediction\n", prediction)
    print("Desired prediction\n", target_check)